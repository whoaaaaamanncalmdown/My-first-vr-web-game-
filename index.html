
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>BO2 VR Prototype - Full Build</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #000;
        font-family: system-ui, sans-serif;
    }
    #playVrButton {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 14px 28px;
        font-size: 18px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        background: #00bcd4;
        color: #000;
        z-index: 10;
    }
    #playVrButton:hover {
        background: #14d4ec;
    }
</style>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
import { VRButton } from "https://unpkg.com/three@0.160.0/examples/jsm/webxr/VRButton.js";

let scene, camera, renderer, clock;
let dolly;
let leftController, rightController;
let leftHandMesh, rightHandMesh, pistolMesh;

const forwardVec = new THREE.Vector3();
const sideVec = new THREE.Vector3();
const colliders = []; // walls + crates

init();
animate();

function init() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    scene.fog = new THREE.Fog(0x000000, 20, 60);

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 200);

    // DOLLY (player rig)
    dolly = new THREE.Group();
    dolly.position.set(0, 1.6, 10);
    dolly.add(camera);
    scene.add(dolly);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
    hemi.position.set(0, 50, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(10, 20, 10);
    scene.add(dir);

    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // VR button
    const vrBtn = VRButton.createButton(renderer);
    vrBtn.style.display = "none";
    document.body.appendChild(vrBtn);

    const playBtn = document.createElement("button");
    playBtn.id = "playVrButton";
    playBtn.textContent = "Play in VR";
    playBtn.onclick = () => vrBtn.click();
    document.body.appendChild(playBtn);

    clock = new THREE.Clock();

    createMap();
    setupControllers();

    window.addEventListener("resize", onWindowResize);
}

function createMap() {
    const floorSize = 40;

    // Floor
    const floorGeo = new THREE.PlaneGeometry(floorSize, floorSize);
    const floorMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Walls
    const wallMat = new THREE.MeshStandardMaterial({ color: 0x333333 });

    addWall(0, 1.5, -floorSize / 2, floorSize, 3, 0.5, wallMat);
    addWall(0, 1.5, floorSize / 2, floorSize, 3, 0.5, wallMat);
    addWall(-floorSize / 2, 1.5, 0, 0.5, 3, floorSize, wallMat);
    addWall(floorSize / 2, 1.5, 0, 0.5, 3, floorSize, wallMat);

    // Crates
    const crateMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
    const crateGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
    const crates = [
        [-4, 0.6, -4],
        [4, 0.6, -4],
        [-4, 0.6, 4],
        [4, 0.6, 4],
        [0, 0.9, 0]
    ];

    crates.forEach(([x, y, z]) => {
        const crate = new THREE.Mesh(crateGeo, crateMat);
        crate.position.set(x, y, z);
        scene.add(crate);
        addCollider(crate);
    });
}

function addWall(x, y, z, w, h, d, mat) {
    const geo = new THREE.BoxGeometry(w, h, d);
    const wall = new THREE.Mesh(geo, mat);
    wall.position.set(x, y, z);
    scene.add(wall);
    addCollider(wall);
}

function addCollider(mesh) {
    mesh.geometry.computeBoundingBox();
    colliders.push(mesh);
}

function setupControllers() {
    // LEFT CONTROLLER
    leftController = renderer.xr.getController(0);
    leftController.addEventListener("connected", () => {
        leftHandMesh = createHandMesh(0x00ffcc);
        leftController.add(leftHandMesh);
    });
    scene.add(leftController);

    // RIGHT CONTROLLER
    rightController = renderer.xr.getController(1);
    rightController.addEventListener("connected", () => {
        rightHandMesh = createHandMesh(0xffcc00);
        rightController.add(rightHandMesh);

        pistolMesh = createPistolMesh();
        pistolMesh.position.set(0.03, -0.05, -0.12);
        pistolMesh.rotation.set(-Math.PI / 2, 0.15, 0);
        rightController.add(pistolMesh);
    });
    scene.add(rightController);
}

function createHandMesh(color) {
    const geo = new THREE.BoxGeometry(0.06, 0.1, 0.16);
    const mat = new THREE.MeshStandardMaterial({ color });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(0, -0.03, -0.05);
    return mesh;
}

function createPistolMesh() {
    const group = new THREE.Group();

    const handle = new THREE.Mesh(
        new THREE.BoxGeometry(0.03, 0.08, 0.02),
        new THREE.MeshStandardMaterial({ color: 0x111111 })
    );
    handle.position.set(0, -0.04, 0);
    group.add(handle);

    const barrel = new THREE.Mesh(
        new THREE.BoxGeometry(0.02, 0.02, 0.18),
        new THREE.MeshStandardMaterial({ color: 0x222222 })
    );
    barrel.position.set(0, 0.0, -0.09);
    group.add(barrel);

    const slide = new THREE.Mesh(
        new THREE.BoxGeometry(0.03, 0.03, 0.14),
        new THREE.MeshStandardMaterial({ color: 0x555555 })
    );
    slide.position.set(0, 0.01, -0.08);
    group.add(slide);

    return group;
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    renderer.setAnimationLoop(renderLoop);
}

function renderLoop() {
    const delta = clock.getDelta();
    handleLocomotion(delta);
    handleShooting();
    renderer.render(scene, camera);
}

// ---------------- MOVEMENT + COLLISION ----------------

let vel = new THREE.Vector3();

function getJoystickAxes(source) {
    if (!source.gamepad) return { x: 0, y: 0 };

    const axes = source.gamepad.axes || [];
    let x = axes[2] ?? axes[0] ?? 0;
    let y = axes[3] ?? axes[1] ?? 0;

    return { x, y };
}

function tryMove(moveVec) {
    const nextPos = dolly.position.clone().add(moveVec);
    const sphere = new THREE.Sphere(nextPos, 0.3);

    for (const mesh of colliders) {
        const box = new THREE.Box3().setFromObject(mesh);
        if (box.intersectsSphere(sphere)) return; // block movement
    }

    dolly.position.copy(nextPos);
}

function handleLocomotion(delta) {
    const session = renderer.xr.getSession();
    if (!session) return;

    let inputX = 0, inputY = 0;

    for (const source of session.inputSources) {
        if (source.handedness !== "left") continue;
        const axes = getJoystickAxes(source);
        inputX = axes.x;
        inputY = axes.y;
        break;
    }

    const dead = 0.15;
    if (Math.abs(inputX) < dead) inputX = 0;
    if (Math.abs(inputY) < dead) inputY = 0;

    const accel = 6;
    const maxSpeed = 3;

    vel.x += (-inputX * accel - vel.x) * delta;
    vel.z += (-inputY * accel - vel.z) * delta;

    if (vel.length() > maxSpeed) vel.setLength(maxSpeed);

    const dir = new THREE.Vector3();
    camera.getWorldDirection(dir);
    dir.y = 0;
    dir.normalize();

    const right = new THREE.Vector3();
    right.crossVectors(camera.up, dir).normalize();

    const move = new THREE.Vector3();
    move.addScaledVector(dir, vel.z * delta);
    move.addScaledVector(right, vel.x * delta);

    tryMove(move);
}

// ---------------- SHOOTING ----------------

let lastShot = 0;
const fireRate = 150;

function handleShooting() {
    const session = renderer.xr.getSession();
    if (!session) return;

    for (const source of session.inputSources) {
        if (source.handedness !== "right") continue;
        if (!source.gamepad) continue;

        const trigger = source.gamepad.buttons[0]?.value || 0;

        if (trigger > 0.5 && performance.now() - lastShot > fireRate) {
            lastShot = performance.now();
            shootRay();
        }
    }
}

function shootRay() {
    if (!pistolMesh) return;

    const origin = new THREE.Vector3();
    const direction = new THREE.Vector3();

    pistolMesh.getWorldPosition(origin);
    pistolMesh.getWorldDirection(direction);

    const ray = new THREE.Raycaster(origin, direction);
    const hits = ray.intersectObjects(scene.children, true);

    if (hits.length > 0) {
        console.log("Hit:", hits[0].object);
    }
}

</script>
</head>
<body></body>
</html>
